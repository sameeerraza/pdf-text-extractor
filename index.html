<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF OCR Extractor</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; }
    h1 { color: #333; }
    .controls { margin-bottom: 15px; }
    .controls label { margin-right: 10px; font-weight: bold; }
    button { padding: 8px 16px; margin: 5px; cursor: pointer; border: none; border-radius: 5px; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    #progressSection { display: none; margin: 15px 0; }
    #progressBar { width: 100%; height: 20px; background: #ddd; border-radius: 5px; overflow: hidden; }
    #progressFill { height: 100%; width: 0%; background: #4caf50; transition: width 0.3s; }
    #statusMessage { margin-top: 10px; font-size: 14px; }
    #preview { display: none; margin-top: 20px; background: #fff; padding: 15px; border: 1px solid #ccc; border-radius: 5px; height: 200px; overflow-y: auto; white-space: pre-wrap; font-family: monospace; font-size: 14px; }
  </style>
</head>
<body>
  <h1>üìÑ PDF OCR Extractor</h1>

  <div class="controls">
    <label for="fileInput">Select PDF:</label>
    <input type="file" id="fileInput" accept="application/pdf">

    <label for="resolutionSelect">OCR Quality:</label>
    <select id="resolutionSelect">
      <option value="1.5">Low (Faster)</option>
      <option value="2.0">Medium</option>
      <option value="2.5" selected>High (Slower, More Accurate)</option>
    </select>
  </div>

  <div>
    <button id="extractBtn">Extract Text</button>
    <button id="downloadBtn" style="display:none;">Download TXT</button>
    <button id="resetBtn" style="display:none;">Reset</button>
  </div>

  <div id="progressSection">
    <div id="progressBar"><div id="progressFill"></div></div>
    <div id="statusMessage">Initializing...</div>
  </div>

  <div id="preview"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    let selectedFile = null;
    let extractedText = '';
    const fileInput = document.getElementById('fileInput');
    const extractBtn = document.getElementById('extractBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn = document.getElementById('resetBtn');
    const progressSection = document.getElementById('progressSection');
    const progressFill = document.getElementById('progressFill');
    const statusMessage = document.getElementById('statusMessage');
    const preview = document.getElementById('preview');
    const resolutionSelect = document.getElementById('resolutionSelect');

    fileInput.addEventListener('change', e => {
      selectedFile = e.target.files[0];
      if (selectedFile) {
        showStatus(`‚úÖ Selected: ${selectedFile.name}`, 'success');
      }
    });

    extractBtn.addEventListener('click', extractText);
    downloadBtn.addEventListener('click', () => {
      const blob = new Blob([extractedText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = selectedFile.name.replace(/\.pdf$/i, '.txt');
      a.click();
      URL.revokeObjectURL(url);
    });
    resetBtn.addEventListener('click', () => location.reload());

    function showProgress(percent, message) {
      progressFill.style.width = percent + '%';
      statusMessage.textContent = message;
    }

    function showStatus(msg, type) {
      statusMessage.textContent = msg;
      statusMessage.style.color = type === 'error' ? 'red' : 'green';
    }

    async function extractText() {
      if (!selectedFile) return;

      extractBtn.disabled = true;
      downloadBtn.style.display = 'none';
      resetBtn.style.display = 'none';
      progressSection.style.display = 'block';
      extractedText = '';
      preview.style.display = 'block';
      preview.textContent = '';

      try {
        showProgress(5, 'üìñ Loading PDF document...');

        const arrayBuffer = await selectedFile.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

        showProgress(15, 'üìä Analyzing document structure...');

        const totalPages = pdf.numPages;
        let allText = `üìÑ EXTRACTED TEXT FROM: ${selectedFile.name}\n`;
        allText += `üìÖ Processed on: ${new Date().toLocaleString()}\n`;
        allText += `üìë Total Pages: ${totalPages}\n`;
        allText += `${'='.repeat(60)}\n\n`;

        const scale = parseFloat(resolutionSelect.value);

        async function batchProcess(items, batchSize, processFn) {
          let results = [];
          for (let i = 0; i < items.length; i += batchSize) {
            showProgress(15 + (i / items.length) * 70, `üîç Processing pages ${i+1}-${Math.min(i+batchSize, items.length)} of ${items.length}...`);
            const batch = items.slice(i, i + batchSize);
            const batchResults = await Promise.all(batch.map(processFn));
            results = results.concat(batchResults);
          }
          return results;
        }

        async function processPage(pageNum) {
          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale });

          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width = viewport.width;

          await page.render({ canvasContext: context, viewport }).promise;

          const imageData = canvas.toDataURL('image/png');

          let lastProgress = 0;
          const result = await Tesseract.recognize(imageData, 'eng', {
            logger: m => {
              if (m.status === 'recognizing text') {
                const ocrProgress = Math.round(m.progress * 100);
                if (ocrProgress !== lastProgress) {
                  showProgress(15 + (pageNum / totalPages) * 70, `ü§ñ OCR page ${pageNum}... ${ocrProgress}%`);
                  lastProgress = ocrProgress;
                }
              }
            }
          });

          return {
            pageNum,
            text: result.data.text.trim()
          };
        }

        const pageNumbers = Array.from({ length: totalPages }, (_, i) => i + 1);
        const batchSize = 3;
        const results = await batchProcess(pageNumbers, batchSize, processPage);

        results.sort((a, b) => a.pageNum - b.pageNum);
        for (const r of results) {
          allText += `üìÑ PAGE ${r.pageNum}\n`;
          allText += `-`.repeat(40) + '\n';
          allText += r.text + '\n\n';
        }

        extractedText = allText;
        preview.textContent = extractedText;
        showProgress(100, 'üéâ Text extraction completed!');

        setTimeout(() => {
          progressSection.style.display = 'none';
          downloadBtn.style.display = 'inline-block';
          resetBtn.style.display = 'inline-block';
          showStatus(`üéâ Extracted text from ${totalPages} page(s)!`, 'success');
        }, 1000);

      } catch (error) {
        console.error('Error:', error);
        showStatus('‚ùå Error extracting text: ' + error.message, 'error');
        progressSection.style.display = 'none';
      } finally {
        extractBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
